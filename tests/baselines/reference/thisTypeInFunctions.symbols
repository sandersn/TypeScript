=== tests/cases/conformance/types/thisType/thisTypeInFunctions.ts ===
// body checking
class C {
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))

    n: number;
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))

    explicitThis(this: this, m: number): number {
>explicitThis : Symbol(explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 3, 17))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 3, 28))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 3, 28))
    }
    implicitThis(m: number): number {
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 6, 17))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 6, 17))
    }
    explicitC(this: C, m: number): number {
>explicitC : Symbol(explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 9, 14))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 9, 22))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 9, 22))
    }
    explicitProperty(this: {n: number}, m: number): number {
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 12, 21))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 12, 39))

        return this.n + m;
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 12, 26))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 12, 39))
    }
    explicitVoid(this: void, m: number): number {
>explicitVoid : Symbol(explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 15, 17))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 15, 28))

        return m + 1;
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 15, 28))
    }
}
class D extends C { }
>D : Symbol(D, Decl(thisTypeInFunctions.ts, 18, 1))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))

class B {
>B : Symbol(B, Decl(thisTypeInFunctions.ts, 19, 21))

    n: number;
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 20, 9))
}
interface I {
>I : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))

    a: number;
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 23, 13))

    explicitVoid1(this: void): number;
>explicitVoid1 : Symbol(explicitVoid1, Decl(thisTypeInFunctions.ts, 24, 14))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 25, 18))

    explicitVoid2(this: void): number;
>explicitVoid2 : Symbol(explicitVoid2, Decl(thisTypeInFunctions.ts, 25, 38))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 26, 18))

    explicitStructural(this: {a: number}): number;
>explicitStructural : Symbol(explicitStructural, Decl(thisTypeInFunctions.ts, 26, 38))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 27, 23))
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 27, 30))

    explicitInterface(this: I): number;
>explicitInterface : Symbol(explicitInterface, Decl(thisTypeInFunctions.ts, 27, 50))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 28, 22))
>I : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))

    explicitThis(this: this): number;
>explicitThis : Symbol(explicitThis, Decl(thisTypeInFunctions.ts, 28, 39))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 29, 17))

    implicitMethod(): number;
>implicitMethod : Symbol(implicitMethod, Decl(thisTypeInFunctions.ts, 29, 37))

    implicitFunction: () => number;
>implicitFunction : Symbol(implicitFunction, Decl(thisTypeInFunctions.ts, 30, 29))
}
function explicitStructural(this: { y: number }, x: number): number {
>explicitStructural : Symbol(explicitStructural, Decl(thisTypeInFunctions.ts, 32, 1))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 33, 28))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 33, 35))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 33, 48))

    return x + this.y;
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 33, 48))
>this.y : Symbol(y, Decl(thisTypeInFunctions.ts, 33, 35))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 33, 33))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 33, 35))
}
function justThis(this: { y: number }): number {
>justThis : Symbol(justThis, Decl(thisTypeInFunctions.ts, 35, 1))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 36, 18))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 36, 25))

    return this.y;
>this.y : Symbol(y, Decl(thisTypeInFunctions.ts, 36, 25))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 36, 23))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 36, 25))
}
function implicitThis(n: number): number {
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 38, 1))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 39, 22))

    return 12;
}
let impl: I = {
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>I : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))

    a: 12,
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 42, 15))

    explicitVoid2: () => this.a, // ok, this: any because it refers to some outer object (window?)
>explicitVoid2 : Symbol(explicitVoid2, Decl(thisTypeInFunctions.ts, 43, 10))

    explicitVoid1() { return 12; },
>explicitVoid1 : Symbol(explicitVoid1, Decl(thisTypeInFunctions.ts, 44, 32))

    explicitStructural() {
>explicitStructural : Symbol(explicitStructural, Decl(thisTypeInFunctions.ts, 45, 35))

        return this.a;
>this.a : Symbol(a, Decl(thisTypeInFunctions.ts, 27, 30))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 27, 28))
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 27, 30))

    },
    explicitInterface() {
>explicitInterface : Symbol(explicitInterface, Decl(thisTypeInFunctions.ts, 48, 6))

        return this.a;
>this.a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))
>this : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))
>a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))

    },
    explicitThis() {
>explicitThis : Symbol(explicitThis, Decl(thisTypeInFunctions.ts, 51, 6))

        return this.a;
>this.a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))
>this : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))
>a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))

    },
    implicitMethod() {
>implicitMethod : Symbol(implicitMethod, Decl(thisTypeInFunctions.ts, 54, 6))

        return this.a;
>this.a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))
>this : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))
>a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))

    },
    implicitFunction: () => this.a, // ok, this: any because it refers to some outer object (window?)
>implicitFunction : Symbol(implicitFunction, Decl(thisTypeInFunctions.ts, 57, 6))
}
impl.explicitVoid1 = function () { return 12; };
>impl.explicitVoid1 : Symbol(I.explicitVoid1, Decl(thisTypeInFunctions.ts, 24, 14))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitVoid1 : Symbol(I.explicitVoid1, Decl(thisTypeInFunctions.ts, 24, 14))

impl.explicitVoid2 = () => 12;
>impl.explicitVoid2 : Symbol(I.explicitVoid2, Decl(thisTypeInFunctions.ts, 25, 38))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitVoid2 : Symbol(I.explicitVoid2, Decl(thisTypeInFunctions.ts, 25, 38))

impl.explicitStructural = function() { return this.a; };
>impl.explicitStructural : Symbol(I.explicitStructural, Decl(thisTypeInFunctions.ts, 26, 38))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitStructural : Symbol(I.explicitStructural, Decl(thisTypeInFunctions.ts, 26, 38))
>this.a : Symbol(a, Decl(thisTypeInFunctions.ts, 27, 30))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 27, 28))
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 27, 30))

impl.explicitInterface = function() { return this.a; };
>impl.explicitInterface : Symbol(I.explicitInterface, Decl(thisTypeInFunctions.ts, 27, 50))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitInterface : Symbol(I.explicitInterface, Decl(thisTypeInFunctions.ts, 27, 50))
>this.a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))
>this : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))
>a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))

impl.explicitStructural = () => 12;
>impl.explicitStructural : Symbol(I.explicitStructural, Decl(thisTypeInFunctions.ts, 26, 38))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitStructural : Symbol(I.explicitStructural, Decl(thisTypeInFunctions.ts, 26, 38))

impl.explicitInterface = () => 12;
>impl.explicitInterface : Symbol(I.explicitInterface, Decl(thisTypeInFunctions.ts, 27, 50))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitInterface : Symbol(I.explicitInterface, Decl(thisTypeInFunctions.ts, 27, 50))

impl.explicitThis = function () { return this.a; };
>impl.explicitThis : Symbol(I.explicitThis, Decl(thisTypeInFunctions.ts, 28, 39))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>explicitThis : Symbol(I.explicitThis, Decl(thisTypeInFunctions.ts, 28, 39))
>this.a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))
>this : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))
>a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))

impl.implicitMethod = function () { return this.a; };
>impl.implicitMethod : Symbol(I.implicitMethod, Decl(thisTypeInFunctions.ts, 29, 37))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>implicitMethod : Symbol(I.implicitMethod, Decl(thisTypeInFunctions.ts, 29, 37))
>this.a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))
>this : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))
>a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))

impl.implicitMethod = () => 12;
>impl.implicitMethod : Symbol(I.implicitMethod, Decl(thisTypeInFunctions.ts, 29, 37))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>implicitMethod : Symbol(I.implicitMethod, Decl(thisTypeInFunctions.ts, 29, 37))

impl.implicitFunction = () => this.a; // ok, this: any because it refers to some outer object (window?)
>impl.implicitFunction : Symbol(I.implicitFunction, Decl(thisTypeInFunctions.ts, 30, 29))
>impl : Symbol(impl, Decl(thisTypeInFunctions.ts, 42, 3))
>implicitFunction : Symbol(I.implicitFunction, Decl(thisTypeInFunctions.ts, 30, 29))

// parameter checking
let ok: {y: number, f: (this: { y: number }, x: number) => number} = { y: 12, f: explicitStructural };
>ok : Symbol(ok, Decl(thisTypeInFunctions.ts, 71, 3))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 71, 9))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 71, 19))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 71, 24))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 71, 31))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 71, 44))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 71, 70))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 71, 77))
>explicitStructural : Symbol(explicitStructural, Decl(thisTypeInFunctions.ts, 32, 1))

let implicitAnyOk: {notSpecified: number, f: (x: number) => number} = { notSpecified: 12, f: implicitThis };
>implicitAnyOk : Symbol(implicitAnyOk, Decl(thisTypeInFunctions.ts, 72, 3))
>notSpecified : Symbol(notSpecified, Decl(thisTypeInFunctions.ts, 72, 20))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 72, 41))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 72, 46))
>notSpecified : Symbol(notSpecified, Decl(thisTypeInFunctions.ts, 72, 71))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 72, 89))
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 38, 1))

ok.f(13);
>ok.f : Symbol(f, Decl(thisTypeInFunctions.ts, 71, 19))
>ok : Symbol(ok, Decl(thisTypeInFunctions.ts, 71, 3))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 71, 19))

implicitThis(12);
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 38, 1))

implicitAnyOk.f(12);
>implicitAnyOk.f : Symbol(f, Decl(thisTypeInFunctions.ts, 72, 41))
>implicitAnyOk : Symbol(implicitAnyOk, Decl(thisTypeInFunctions.ts, 72, 3))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 72, 41))

let c = new C();
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))

let d = new D();
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 78, 3))
>D : Symbol(D, Decl(thisTypeInFunctions.ts, 18, 1))

let ripped = c.explicitC;
>ripped : Symbol(ripped, Decl(thisTypeInFunctions.ts, 79, 3))
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))

c.explicitC(12);
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))

c.explicitProperty(12);
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))

c.explicitThis(12);
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))

c.implicitThis(12);
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))

d.explicitC(12);
>d.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 78, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))

d.explicitProperty(12);
>d.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 78, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))

d.explicitThis(12);
>d.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 78, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))

d.implicitThis(12);
>d.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>d : Symbol(d, Decl(thisTypeInFunctions.ts, 78, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))

let reconstructed: { 
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 88, 3))

    n: number,
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 88, 20))

    explicitThis(this: C, m: number): number, // note: this: this is not allowed in an object literal type.
>explicitThis : Symbol(explicitThis, Decl(thisTypeInFunctions.ts, 89, 14))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 90, 17))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 90, 25))

    implicitThis(m: number): number,
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 90, 45))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 91, 17))

    explicitC(this: C, m: number): number,
>explicitC : Symbol(explicitC, Decl(thisTypeInFunctions.ts, 91, 36))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 92, 14))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 92, 22))

    explicitProperty: (this: {n : number}, m: number) => number,
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 92, 42))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 93, 23))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 93, 30))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 93, 42))

    explicitVoid(this: void, m: number): number,
>explicitVoid : Symbol(explicitVoid, Decl(thisTypeInFunctions.ts, 93, 64))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 94, 17))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 94, 28))

} = { 
    n: 12,
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 95, 5))

    explicitThis: c.explicitThis,
>explicitThis : Symbol(explicitThis, Decl(thisTypeInFunctions.ts, 96, 10))
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))

    implicitThis: c.implicitThis,
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 97, 33))
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))

    explicitC: c.explicitC,
>explicitC : Symbol(explicitC, Decl(thisTypeInFunctions.ts, 98, 33))
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))

    explicitProperty: c.explicitProperty,
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 99, 27))
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))

    explicitVoid: c.explicitVoid
>explicitVoid : Symbol(explicitVoid, Decl(thisTypeInFunctions.ts, 100, 41))
>c.explicitVoid : Symbol(C.explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitVoid : Symbol(C.explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))

};
reconstructed.explicitProperty(11);
>reconstructed.explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 92, 42))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 88, 3))
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 92, 42))

reconstructed.implicitThis(11);
>reconstructed.implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 90, 45))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 88, 3))
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 90, 45))

// assignment checking
let unboundToSpecified: (this: { y: number }, x: number) => number = x => x + this.y; // ok, this:any
>unboundToSpecified : Symbol(unboundToSpecified, Decl(thisTypeInFunctions.ts, 107, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 107, 25))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 107, 32))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 107, 45))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 107, 68))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 107, 68))

let specifiedToSpecified: (this: {y: number}, x: number) => number = explicitStructural;
>specifiedToSpecified : Symbol(specifiedToSpecified, Decl(thisTypeInFunctions.ts, 108, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 108, 27))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 108, 34))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 108, 45))
>explicitStructural : Symbol(explicitStructural, Decl(thisTypeInFunctions.ts, 32, 1))

let anyToSpecified: (this: { y: number }, x: number) => number = function(x: number): number { return x + 12; };
>anyToSpecified : Symbol(anyToSpecified, Decl(thisTypeInFunctions.ts, 109, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 109, 21))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 109, 28))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 109, 41))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 109, 74))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 109, 74))

let unspecifiedLambda: (x: number) => number = x => x + 12;
>unspecifiedLambda : Symbol(unspecifiedLambda, Decl(thisTypeInFunctions.ts, 111, 3))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 111, 24))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 111, 46))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 111, 46))

let specifiedLambda: (this: void, x: number) => number = x => x + 12;
>specifiedLambda : Symbol(specifiedLambda, Decl(thisTypeInFunctions.ts, 112, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 112, 22))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 112, 33))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 112, 56))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 112, 56))

let unspecifiedLambdaToSpecified: (this: {y: number}, x: number) => number = unspecifiedLambda;
>unspecifiedLambdaToSpecified : Symbol(unspecifiedLambdaToSpecified, Decl(thisTypeInFunctions.ts, 113, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 113, 35))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 113, 42))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 113, 53))
>unspecifiedLambda : Symbol(unspecifiedLambda, Decl(thisTypeInFunctions.ts, 111, 3))

let specifiedLambdaToSpecified: (this: {y: number}, x: number) => number = specifiedLambda;
>specifiedLambdaToSpecified : Symbol(specifiedLambdaToSpecified, Decl(thisTypeInFunctions.ts, 114, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 114, 33))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 114, 40))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 114, 51))
>specifiedLambda : Symbol(specifiedLambda, Decl(thisTypeInFunctions.ts, 112, 3))


let explicitCFunction: (this: C, m: number) => number;
>explicitCFunction : Symbol(explicitCFunction, Decl(thisTypeInFunctions.ts, 117, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 117, 24))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 117, 32))

let explicitPropertyFunction: (this: {n: number}, m: number) => number;
>explicitPropertyFunction : Symbol(explicitPropertyFunction, Decl(thisTypeInFunctions.ts, 118, 3))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 118, 31))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 118, 38))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 118, 49))

c.explicitC = explicitCFunction;
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>explicitCFunction : Symbol(explicitCFunction, Decl(thisTypeInFunctions.ts, 117, 3))

c.explicitC = function(this: C, m: number) { return this.n + m };
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 120, 23))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 120, 31))
>this.n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 120, 31))

c.explicitProperty = explicitPropertyFunction;
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>explicitPropertyFunction : Symbol(explicitPropertyFunction, Decl(thisTypeInFunctions.ts, 118, 3))

c.explicitProperty = function(this: {n: number}, m: number) { return this.n + m };
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 122, 30))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 122, 37))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 122, 48))
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 122, 37))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 122, 35))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 122, 37))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 122, 48))

c.explicitProperty = reconstructed.explicitProperty;
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>reconstructed.explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 92, 42))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 88, 3))
>explicitProperty : Symbol(explicitProperty, Decl(thisTypeInFunctions.ts, 92, 42))

// lambdas are assignable to anything
c.explicitC = m => m;
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 126, 13))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 126, 13))

c.explicitThis = m => m;
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 127, 16))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 127, 16))

c.explicitProperty = m => m;
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 128, 20))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 128, 20))

// this inside lambdas refer to outer scope
// the outer-scoped lambda at top-level is still just `any`
c.explicitC = m => m + this.n;
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 132, 13))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 132, 13))

c.explicitThis = m => m + this.n;
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 133, 16))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 133, 16))

c.explicitProperty = m => m + this.n;
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 134, 20))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 134, 20))

//NOTE: this=C here, I guess?
c.explicitThis = explicitCFunction;
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>explicitCFunction : Symbol(explicitCFunction, Decl(thisTypeInFunctions.ts, 117, 3))

c.explicitThis = function(this: C, m: number) { return this.n + m };
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 138, 26))
>C : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 138, 34))
>this.n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 138, 34))

// this:any compatibility
c.explicitC = function(m: number) { return this.n + m };
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 141, 23))
>this.n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 141, 23))

c.explicitProperty = function(m: number) { return this.n + m };
>c.explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitProperty : Symbol(C.explicitProperty, Decl(thisTypeInFunctions.ts, 11, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 142, 30))
>this.n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 12, 26))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 12, 28))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 142, 30))

c.explicitThis = function(m: number) { return this.n + m };
>c.explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitThis : Symbol(C.explicitThis, Decl(thisTypeInFunctions.ts, 2, 14))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 143, 26))
>this.n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 143, 26))

c.implicitThis = function(m: number) { return this.n + m };
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 144, 26))
>this.n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>this : Symbol(C, Decl(thisTypeInFunctions.ts, 0, 0))
>n : Symbol(C.n, Decl(thisTypeInFunctions.ts, 1, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 144, 26))

c.implicitThis = reconstructed.implicitThis;
>c.implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>implicitThis : Symbol(C.implicitThis, Decl(thisTypeInFunctions.ts, 5, 5))
>reconstructed.implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 90, 45))
>reconstructed : Symbol(reconstructed, Decl(thisTypeInFunctions.ts, 88, 3))
>implicitThis : Symbol(implicitThis, Decl(thisTypeInFunctions.ts, 90, 45))

c.explicitC = function(this: B, m: number) { return this.n + m };
>c.explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitC : Symbol(C.explicitC, Decl(thisTypeInFunctions.ts, 8, 5))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 147, 23))
>B : Symbol(B, Decl(thisTypeInFunctions.ts, 19, 21))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 147, 31))
>this.n : Symbol(B.n, Decl(thisTypeInFunctions.ts, 20, 9))
>this : Symbol(B, Decl(thisTypeInFunctions.ts, 19, 21))
>n : Symbol(B.n, Decl(thisTypeInFunctions.ts, 20, 9))
>m : Symbol(m, Decl(thisTypeInFunctions.ts, 147, 31))

// this:void compatibility
c.explicitVoid = n => n;
>c.explicitVoid : Symbol(C.explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))
>c : Symbol(c, Decl(thisTypeInFunctions.ts, 77, 3))
>explicitVoid : Symbol(C.explicitVoid, Decl(thisTypeInFunctions.ts, 14, 5))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 150, 16))
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 150, 16))

// class-based assignability
class Base1 {
>Base1 : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))

    x: number;
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 153, 13))

    public implicit(): number { return this.x; }
>implicit : Symbol(implicit, Decl(thisTypeInFunctions.ts, 154, 14))
>this.x : Symbol(x, Decl(thisTypeInFunctions.ts, 153, 13))
>this : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 153, 13))

    explicit(this: Base1): number { return this.x; }
>explicit : Symbol(explicit, Decl(thisTypeInFunctions.ts, 155, 48))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 156, 13))
>Base1 : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))
>this.x : Symbol(x, Decl(thisTypeInFunctions.ts, 153, 13))
>this : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 153, 13))

    static implicitStatic(): number { return this.y; }
>implicitStatic : Symbol(Base1.implicitStatic, Decl(thisTypeInFunctions.ts, 156, 52))
>this.y : Symbol(Base1.y, Decl(thisTypeInFunctions.ts, 158, 72))
>this : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))
>y : Symbol(Base1.y, Decl(thisTypeInFunctions.ts, 158, 72))

    static explicitStatic(this: typeof Base1): number { return this.y; }
>explicitStatic : Symbol(Base1.explicitStatic, Decl(thisTypeInFunctions.ts, 157, 54))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 158, 26))
>Base1 : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))
>this.y : Symbol(Base1.y, Decl(thisTypeInFunctions.ts, 158, 72))
>this : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))
>y : Symbol(Base1.y, Decl(thisTypeInFunctions.ts, 158, 72))

    static y: number;
>y : Symbol(Base1.y, Decl(thisTypeInFunctions.ts, 158, 72))

}
class Derived1 extends Base1 {
>Derived1 : Symbol(Derived1, Decl(thisTypeInFunctions.ts, 161, 1))
>Base1 : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))

    y: number
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 162, 30))
}
class Base2 {
>Base2 : Symbol(Base2, Decl(thisTypeInFunctions.ts, 164, 1))

    y: number
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 165, 13))

    implicit(): number { return this.y; }
>implicit : Symbol(implicit, Decl(thisTypeInFunctions.ts, 166, 13))
>this.y : Symbol(y, Decl(thisTypeInFunctions.ts, 165, 13))
>this : Symbol(Base2, Decl(thisTypeInFunctions.ts, 164, 1))
>y : Symbol(y, Decl(thisTypeInFunctions.ts, 165, 13))

    explicit(this: Base1): number { return this.x; }
>explicit : Symbol(explicit, Decl(thisTypeInFunctions.ts, 167, 41))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 168, 13))
>Base1 : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))
>this.x : Symbol(Base1.x, Decl(thisTypeInFunctions.ts, 153, 13))
>this : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))
>x : Symbol(Base1.x, Decl(thisTypeInFunctions.ts, 153, 13))
}
class Derived2 extends Base2 {
>Derived2 : Symbol(Derived2, Decl(thisTypeInFunctions.ts, 169, 1))
>Base2 : Symbol(Base2, Decl(thisTypeInFunctions.ts, 164, 1))

    x: number
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 170, 30))
}
let b1 = new Base1();
>b1 : Symbol(b1, Decl(thisTypeInFunctions.ts, 173, 3))
>Base1 : Symbol(Base1, Decl(thisTypeInFunctions.ts, 150, 24))

let b2 = new Base2();
>b2 : Symbol(b2, Decl(thisTypeInFunctions.ts, 174, 3))
>Base2 : Symbol(Base2, Decl(thisTypeInFunctions.ts, 164, 1))

let d1 = new Derived1();
>d1 : Symbol(d1, Decl(thisTypeInFunctions.ts, 175, 3))
>Derived1 : Symbol(Derived1, Decl(thisTypeInFunctions.ts, 161, 1))

let d2 = new Derived2();
>d2 : Symbol(d2, Decl(thisTypeInFunctions.ts, 176, 3))
>Derived2 : Symbol(Derived2, Decl(thisTypeInFunctions.ts, 169, 1))

d2.implicit = d1.implicit // ok, 'x' and 'y' in { x, y } (d assignable to f and vice versa)
>d2.implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))
>d2 : Symbol(d2, Decl(thisTypeInFunctions.ts, 176, 3))
>implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))
>d1.implicit : Symbol(Base1.implicit, Decl(thisTypeInFunctions.ts, 154, 14))
>d1 : Symbol(d1, Decl(thisTypeInFunctions.ts, 175, 3))
>implicit : Symbol(Base1.implicit, Decl(thisTypeInFunctions.ts, 154, 14))

d1.implicit = d2.implicit // ok, 'x' and 'y' in { x, y } (f assignable to d and vice versa)
>d1.implicit : Symbol(Base1.implicit, Decl(thisTypeInFunctions.ts, 154, 14))
>d1 : Symbol(d1, Decl(thisTypeInFunctions.ts, 175, 3))
>implicit : Symbol(Base1.implicit, Decl(thisTypeInFunctions.ts, 154, 14))
>d2.implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))
>d2 : Symbol(d2, Decl(thisTypeInFunctions.ts, 176, 3))
>implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))

// bivariance-allowed cases
d1.implicit = b2.implicit // ok, 'y' in D: { x, y } (d assignable e) 
>d1.implicit : Symbol(Base1.implicit, Decl(thisTypeInFunctions.ts, 154, 14))
>d1 : Symbol(d1, Decl(thisTypeInFunctions.ts, 175, 3))
>implicit : Symbol(Base1.implicit, Decl(thisTypeInFunctions.ts, 154, 14))
>b2.implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))
>b2 : Symbol(b2, Decl(thisTypeInFunctions.ts, 174, 3))
>implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))

d2.implicit = d1.explicit // ok, 'y' in { x, y } (c assignable to f)
>d2.implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))
>d2 : Symbol(d2, Decl(thisTypeInFunctions.ts, 176, 3))
>implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))
>d1.explicit : Symbol(Base1.explicit, Decl(thisTypeInFunctions.ts, 155, 48))
>d1 : Symbol(d1, Decl(thisTypeInFunctions.ts, 175, 3))
>explicit : Symbol(Base1.explicit, Decl(thisTypeInFunctions.ts, 155, 48))

b1.implicit = d2.implicit // ok, 'x' and 'y' not in C: { x } (c assignable to f) 
>b1.implicit : Symbol(Base1.implicit, Decl(thisTypeInFunctions.ts, 154, 14))
>b1 : Symbol(b1, Decl(thisTypeInFunctions.ts, 173, 3))
>implicit : Symbol(Base1.implicit, Decl(thisTypeInFunctions.ts, 154, 14))
>d2.implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))
>d2 : Symbol(d2, Decl(thisTypeInFunctions.ts, 176, 3))
>implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))

b1.explicit = d2.implicit // ok, 'x' and 'y' not in C: { x } (c assignable to f)
>b1.explicit : Symbol(Base1.explicit, Decl(thisTypeInFunctions.ts, 155, 48))
>b1 : Symbol(b1, Decl(thisTypeInFunctions.ts, 173, 3))
>explicit : Symbol(Base1.explicit, Decl(thisTypeInFunctions.ts, 155, 48))
>d2.implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))
>d2 : Symbol(d2, Decl(thisTypeInFunctions.ts, 176, 3))
>implicit : Symbol(Base2.implicit, Decl(thisTypeInFunctions.ts, 166, 13))

////// use this-type for construction with new ////
function InterfaceThis(this: I) {
>InterfaceThis : Symbol(InterfaceThis, Decl(thisTypeInFunctions.ts, 184, 25))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 187, 23))
>I : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))

    this.a = 12;
>this.a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))
>this : Symbol(I, Decl(thisTypeInFunctions.ts, 22, 1))
>a : Symbol(I.a, Decl(thisTypeInFunctions.ts, 23, 13))
}
function LiteralTypeThis(this: {x: string}) {
>LiteralTypeThis : Symbol(LiteralTypeThis, Decl(thisTypeInFunctions.ts, 189, 1))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 190, 25))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 190, 32))

    this.x = "ok";
>this.x : Symbol(x, Decl(thisTypeInFunctions.ts, 190, 32))
>this : Symbol(, Decl(thisTypeInFunctions.ts, 190, 30))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 190, 32))
}
function AnyThis(this: any) {
>AnyThis : Symbol(AnyThis, Decl(thisTypeInFunctions.ts, 192, 1))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 193, 17))

    this.x = "ok";
}
let interfaceThis = new InterfaceThis();
>interfaceThis : Symbol(interfaceThis, Decl(thisTypeInFunctions.ts, 196, 3))
>InterfaceThis : Symbol(InterfaceThis, Decl(thisTypeInFunctions.ts, 184, 25))

let literalTypeThis = new LiteralTypeThis();
>literalTypeThis : Symbol(literalTypeThis, Decl(thisTypeInFunctions.ts, 197, 3))
>LiteralTypeThis : Symbol(LiteralTypeThis, Decl(thisTypeInFunctions.ts, 189, 1))

let anyThis = new AnyThis();
>anyThis : Symbol(anyThis, Decl(thisTypeInFunctions.ts, 198, 3))
>AnyThis : Symbol(AnyThis, Decl(thisTypeInFunctions.ts, 192, 1))

//// type parameter inference ////
declare var f: { 
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 201, 11))

    (this: void, x: number): number, 
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 202, 5))
>x : Symbol(x, Decl(thisTypeInFunctions.ts, 202, 16))

    call<U>(this: (...argArray: any[]) => U, ...argArray: any[]): U;
>call : Symbol(call, Decl(thisTypeInFunctions.ts, 202, 36))
>U : Symbol(U, Decl(thisTypeInFunctions.ts, 203, 9))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 203, 12))
>argArray : Symbol(argArray, Decl(thisTypeInFunctions.ts, 203, 19))
>U : Symbol(U, Decl(thisTypeInFunctions.ts, 203, 9))
>argArray : Symbol(argArray, Decl(thisTypeInFunctions.ts, 203, 44))
>U : Symbol(U, Decl(thisTypeInFunctions.ts, 203, 9))

};
let n: number = f.call(12);
>n : Symbol(n, Decl(thisTypeInFunctions.ts, 205, 3))
>f.call : Symbol(call, Decl(thisTypeInFunctions.ts, 202, 36))
>f : Symbol(f, Decl(thisTypeInFunctions.ts, 201, 11))
>call : Symbol(call, Decl(thisTypeInFunctions.ts, 202, 36))

function missingTypeIsImplicitAny(this, a: number) { return a; } 
>missingTypeIsImplicitAny : Symbol(missingTypeIsImplicitAny, Decl(thisTypeInFunctions.ts, 205, 27))
>this : Symbol(this, Decl(thisTypeInFunctions.ts, 207, 34))
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 207, 39))
>a : Symbol(a, Decl(thisTypeInFunctions.ts, 207, 39))

